const { exec } = require('child_process');
const fs = require('fs-extra');
const path = require('path');
const config = require('../config');
const log = require('../utils/logger')(module);

class SimpleUpdateManager {
    constructor(bot, sessionManager) {
        this.bot = bot;
        this.sessionManager = sessionManager;
        this.isUpdating = false;
        this.currentVersion = config.bot.version;
        this.tempDir = path.join(__dirname, '../temp-update');
        this.backupDir = path.join(__dirname, '../backup');
    }

    async performUpdate(force = false) {
        if (this.isUpdating) {
            throw new Error('Mise √† jour d√©j√† en cours');
        }

        this.isUpdating = true;
        
        try {
            log.update('üöÄ D√©but de la mise √† jour simplifi√©e...');

            // 1. Sauvegarder les sessions et donn√©es importantes
            const sessionsBefore = this.getSessionsSnapshot();
            await this.backupEssentialData();

            // 2. Cloner la nouvelle version
            await this.cloneNewVersion();

            // 3. Copier les fichiers mis √† jour
            await this.copyUpdatedFiles();

            // 4. Mettre √† jour les d√©pendances
            await this.installDependencies();

            // 5. V√©rifier l'int√©grit√©
            const sessionsAfter = this.getSessionsSnapshot();
            await this.verifyUpdate();

            log.update('‚úÖ Mise √† jour termin√©e avec succ√®s!');
            
            await this.notifyAdmins(
                `‚úÖ *Mise √† jour r√©ussie!*\n\n` +
                `M√©thode: Git Clone Simple\n` +
                `Sessions pr√©serv√©es: ${sessionsAfter.length}/${sessionsBefore.length}\n` +
                `Red√©marrage: Recommand√©`
            );

            return { 
                success: true, 
                method: 'git-clone',
                sessionsBefore: sessionsBefore.length,
                sessionsAfter: sessionsAfter.length,
                restartRecommended: true
            };

        } catch (error) {
            log.error('‚ùå Erreur mise √† jour:', error);
            
            // Restaurer la backup en cas d'erreur
            await this.restoreBackup();
            
            await this.notifyAdmins(
                `‚ùå *√âchec mise √† jour*\n\n` +
                `Erreur: ${error.message}\n` +
                `Syst√®me restaur√© √† la version pr√©c√©dente.`
            );
            
            return { 
                success: false, 
                error: error.message,
                restored: true
            };
        } finally {
            this.isUpdating = false;
            await this.cleanup();
        }
    }

    async cloneNewVersion() {
        return new Promise((resolve, reject) => {
            log.update('üì• Clonage de la nouvelle version...');

            // Nettoyer le dossier temporaire
            exec(`rm -rf ${this.tempDir}`, async () => {
                const repoUrl = `https://github.com/${config.updates.github_repo}.git`;
                
                exec(`git clone ${repoUrl} ${this.tempDir} --depth 1 --branch ${config.updates.branch}`, 
                { timeout: 120000 }, (error, stdout, stderr) => {
                    if (error) {
                        log.error('‚ùå Erreur clonage:', stderr);
                        reject(new Error(`√âchec clonage: ${stderr}`));
                        return;
                    }

                    log.update('‚úÖ Nouvelle version clon√©e');
                    resolve();
                });
            });
        });
    }

    async backupEssentialData() {
        try {
            log.update('üíæ Sauvegarde des donn√©es essentielles...');
            
            await fs.ensureDir(this.backupDir);
            await fs.emptyDir(this.backupDir);

            // Sauvegarder les dossiers critiques
            const essentialFolders = [
                'sessions',
                'custom-commands', 
                'backups',
                'logs'
            ];

            for (const folder of essentialFolders) {
                const source = path.join(process.cwd(), folder);
                const target = path.join(this.backupDir, folder);
                
                if (await fs.pathExists(source)) {
                    await fs.copy(source, target);
                    log.update(`‚úÖ ${folder} sauvegard√©`);
                }
            }

            // Sauvegarder le .env
            const envPath = path.join(process.cwd(), '.env');
            if (await fs.pathExists(envPath)) {
                await fs.copy(envPath, path.join(this.backupDir, '.env'));
            }

            log.update('‚úÖ Sauvegarde termin√©e');

        } catch (error) {
            log.error('‚ùå Erreur sauvegarde:', error);
            throw error;
        }
    }

    async copyUpdatedFiles() {
        try {
            log.update('üìÅ Copie des fichiers mis √† jour...');

            const sourceDir = this.tempDir;
            const targetDir = process.cwd();

            // Liste des fichiers/dossiers √† exclure de la copie
            const excludeList = [
                'sessions',
                'custom-commands',
                'backups', 
                'logs',
                'node_modules',
                '.env',
                '.git'
            ];

            // Obtenir tous les fichiers du nouveau clone
            const allFiles = await fs.readdir(sourceDir);
            
            for (const file of allFiles) {
                if (excludeList.includes(file)) {
                    continue; // Ignorer les dossiers exclus
                }

                const sourcePath = path.join(sourceDir, file);
                const targetPath = path.join(targetDir, file);

                try {
                    // Supprimer l'ancienne version si elle existe
                    if (await fs.pathExists(targetPath)) {
                        await fs.remove(targetPath);
                    }

                    // Copier la nouvelle version
                    await fs.copy(sourcePath, targetPath);
                    log.update(`‚úÖ ${file} mis √† jour`);

                } catch (error) {
                    log.warn(`‚ö†Ô∏è  Impossible de mettre √† jour ${file}: ${error.message}`);
                }
            }

            // Restaurer les donn√©es sauvegard√©es
            await this.restoreEssentialData();

            log.update('‚úÖ Copie des fichiers termin√©e');

        } catch (error) {
            log.error('‚ùå Erreur copie fichiers:', error);
            throw error;
        }
    }

    async restoreEssentialData() {
        try {
            log.update('üîÑ Restauration des donn√©es essentielles...');

            // Restaurer les dossiers sauvegard√©s
            const essentialFolders = [
                'sessions',
                'custom-commands',
                'backups',
                'logs'
            ];

            for (const folder of essentialFolders) {
                const source = path.join(this.backupDir, folder);
                const target = path.join(process.cwd(), folder);
                
                if (await fs.pathExists(source)) {
                    await fs.copy(source, target);
                    log.update(`‚úÖ ${folder} restaur√©`);
                }
            }

            // Restaurer le .env
            const envBackup = path.join(this.backupDir, '.env');
            const envTarget = path.join(process.cwd(), '.env');
            if (await fs.pathExists(envBackup) && !await fs.pathExists(envTarget)) {
                await fs.copy(envBackup, envTarget);
            }

            log.update('‚úÖ Donn√©es essentielles restaur√©es');

        } catch (error) {
            log.error('‚ùå Erreur restauration donn√©es:', error);
            throw error;
        }
    }

    async installDependencies() {
        return new Promise((resolve, reject) => {
            log.update('üì¶ Installation des d√©pendances...');

            exec('npm install --production --no-audit --no-fund', 
            { 
                cwd: process.cwd(),
                timeout: 120000 
            }, (error, stdout, stderr) => {
                if (error) {
                    log.error('‚ùå Erreur installation d√©pendances:', stderr);
                    reject(new Error(`√âchec installation: ${stderr}`));
                    return;
                }
                
                log.update('‚úÖ D√©pendances install√©es');
                resolve();
            });
        });
    }

    async restoreBackup() {
        try {
            log.update('üîÑ Restauration depuis la sauvegarde...');

            if (!await fs.pathExists(this.backupDir)) {
                log.warn('‚ö†Ô∏è  Aucune sauvegarde trouv√©e');
                return;
            }

            await this.restoreEssentialData();
            log.update('‚úÖ Syst√®me restaur√© depuis sauvegarde');

        } catch (error) {
            log.error('‚ùå Erreur restauration backup:', error);
        }
    }

    async verifyUpdate() {
        try {
            log.update('üîç V√©rification de la mise √† jour...');

            // V√©rifier que les fichiers essentiels existent
            const essentialFiles = [
                'index.js',
                'package.json',
                'config.js'
            ];

            for (const file of essentialFiles) {
                if (!await fs.pathExists(path.join(process.cwd(), file))) {
                    throw new Error(`Fichier manquant apr√®s mise √† jour: ${file}`);
                }
            }

            // V√©rifier la nouvelle version
            const newPackage = require(path.join(process.cwd(), 'package.json'));
            log.update(`‚úÖ Version mise √† jour: ${newPackage.version}`);

            return { success: true, newVersion: newPackage.version };

        } catch (error) {
            log.error('‚ùå Erreur v√©rification mise √† jour:', error);
            throw error;
        }
    }

    getSessionsSnapshot() {
        const sessions = [];
        if (this.sessionManager && this.sessionManager.sessions) {
            for (const [sessionId, sessionData] of this.sessionManager.sessions) {
                sessions.push({
                    sessionId,
                    userId: sessionData.userId,
                    status: sessionData.status
                });
            }
        }
        return sessions;
    }

    async notifyAdmins(message) {
        if (!this.bot) return;

        const adminIds = config.telegram.admin_ids;
        
        for (const adminId of adminIds) {
            try {
                await this.bot.sendMessage(adminId, message, { 
                    parse_mode: 'Markdown'
                });
            } catch (error) {
                log.error(`‚ùå Erreur notification admin ${adminId}:`, error.message);
            }
        }
    }

    async cleanup() {
        try {
            // Nettoyer le dossier temporaire
            if (await fs.pathExists(this.tempDir)) {
                await fs.remove(this.tempDir);
            }
            
            log.update('üßπ Nettoyage termin√©');
        } catch (error) {
            log.error('‚ùå Erreur nettoyage:', error);
        }
    }

    async checkForUpdates() {
        return new Promise((resolve) => {
            log.update('üîç V√©rification des mises √† jour...');
            
            exec('git ls-remote origin HEAD', { timeout: 10000 }, (error, stdout) => {
                if (error) {
                    resolve({ available: false, error: error.message });
                    return;
                }

                const remoteHash = stdout.split('\t')[0];
                
                exec('git rev-parse HEAD', (error, localHash) => {
                    if (error) {
                        resolve({ available: false, error: error.message });
                        return;
                    }

                    const available = remoteHash.trim() !== localHash.trim();
                    
                    resolve({
                        available: available,
                        currentHash: localHash.trim().substring(0, 8),
                        latestHash: remoteHash.trim().substring(0, 8),
                        currentVersion: this.currentVersion
                    });
                });
            });
        });
    }
}

module.exports = SimpleUpdateManager;
